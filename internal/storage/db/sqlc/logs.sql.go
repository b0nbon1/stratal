// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: logs.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countLogsByJobRun = `-- name: CountLogsByJobRun :one
SELECT COUNT(*) FROM logs WHERE job_run_id = $1
`

func (q *Queries) CountLogsByJobRun(ctx context.Context, jobRunID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countLogsByJobRun, jobRunID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countLogsByTaskRun = `-- name: CountLogsByTaskRun :one
SELECT COUNT(*) FROM logs WHERE task_run_id = $1
`

func (q *Queries) CountLogsByTaskRun(ctx context.Context, taskRunID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countLogsByTaskRun, taskRunID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countLogsByType = `-- name: CountLogsByType :one
SELECT COUNT(*) FROM logs WHERE type = $1
`

func (q *Queries) CountLogsByType(ctx context.Context, type_ string) (int64, error) {
	row := q.db.QueryRow(ctx, countLogsByType, type_)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createJobLog = `-- name: CreateJobLog :exec
INSERT INTO logs (type, job_run_id, level, stream, message, metadata)
VALUES ('job', $1, $2, $3, $4, $5)
`

type CreateJobLogParams struct {
	JobRunID pgtype.UUID `json:"job_run_id"`
	Level    string      `json:"level"`
	Stream   string      `json:"stream"`
	Message  string      `json:"message"`
	Metadata []byte      `json:"metadata"`
}

func (q *Queries) CreateJobLog(ctx context.Context, arg CreateJobLogParams) error {
	_, err := q.db.Exec(ctx, createJobLog,
		arg.JobRunID,
		arg.Level,
		arg.Stream,
		arg.Message,
		arg.Metadata,
	)
	return err
}

const createLog = `-- name: CreateLog :exec
INSERT INTO logs (type, job_run_id, task_run_id, timestamp, level, stream, message, metadata)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type CreateLogParams struct {
	Type      string           `json:"type"`
	JobRunID  pgtype.UUID      `json:"job_run_id"`
	TaskRunID pgtype.UUID      `json:"task_run_id"`
	Timestamp pgtype.Timestamp `json:"timestamp"`
	Level     string           `json:"level"`
	Stream    string           `json:"stream"`
	Message   string           `json:"message"`
	Metadata  []byte           `json:"metadata"`
}

func (q *Queries) CreateLog(ctx context.Context, arg CreateLogParams) error {
	_, err := q.db.Exec(ctx, createLog,
		arg.Type,
		arg.JobRunID,
		arg.TaskRunID,
		arg.Timestamp,
		arg.Level,
		arg.Stream,
		arg.Message,
		arg.Metadata,
	)
	return err
}

const createSystemLog = `-- name: CreateSystemLog :exec
INSERT INTO logs (type, level, stream, message, metadata)
VALUES ('system', $1, $2, $3, $4)
`

type CreateSystemLogParams struct {
	Level    string `json:"level"`
	Stream   string `json:"stream"`
	Message  string `json:"message"`
	Metadata []byte `json:"metadata"`
}

func (q *Queries) CreateSystemLog(ctx context.Context, arg CreateSystemLogParams) error {
	_, err := q.db.Exec(ctx, createSystemLog,
		arg.Level,
		arg.Stream,
		arg.Message,
		arg.Metadata,
	)
	return err
}

const createTaskLog = `-- name: CreateTaskLog :exec
INSERT INTO logs (type, job_run_id, task_run_id, level, stream, message, metadata)
VALUES ('task', $1, $2, $3, $4, $5, $6)
`

type CreateTaskLogParams struct {
	JobRunID  pgtype.UUID `json:"job_run_id"`
	TaskRunID pgtype.UUID `json:"task_run_id"`
	Level     string      `json:"level"`
	Stream    string      `json:"stream"`
	Message   string      `json:"message"`
	Metadata  []byte      `json:"metadata"`
}

func (q *Queries) CreateTaskLog(ctx context.Context, arg CreateTaskLogParams) error {
	_, err := q.db.Exec(ctx, createTaskLog,
		arg.JobRunID,
		arg.TaskRunID,
		arg.Level,
		arg.Stream,
		arg.Message,
		arg.Metadata,
	)
	return err
}

const deleteLog = `-- name: DeleteLog :exec
DELETE FROM logs
WHERE id = $1
`

func (q *Queries) DeleteLog(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteLog, id)
	return err
}

const deleteLogsByJobRun = `-- name: DeleteLogsByJobRun :exec
DELETE FROM logs
WHERE job_run_id = $1
`

func (q *Queries) DeleteLogsByJobRun(ctx context.Context, jobRunID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteLogsByJobRun, jobRunID)
	return err
}

const deleteLogsByTaskRun = `-- name: DeleteLogsByTaskRun :exec
DELETE FROM logs
WHERE task_run_id = $1
`

func (q *Queries) DeleteLogsByTaskRun(ctx context.Context, taskRunID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteLogsByTaskRun, taskRunID)
	return err
}

const deleteLogsByType = `-- name: DeleteLogsByType :exec
DELETE FROM logs
WHERE type = $1
`

func (q *Queries) DeleteLogsByType(ctx context.Context, type_ string) error {
	_, err := q.db.Exec(ctx, deleteLogsByType, type_)
	return err
}

const getLog = `-- name: GetLog :one
SELECT id, type, job_run_id, task_run_id, timestamp, level, stream, message, metadata, created_at
FROM logs
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetLog(ctx context.Context, id int64) (Log, error) {
	row := q.db.QueryRow(ctx, getLog, id)
	var i Log
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.JobRunID,
		&i.TaskRunID,
		&i.Timestamp,
		&i.Level,
		&i.Stream,
		&i.Message,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const listLogs = `-- name: ListLogs :many
SELECT id, type, job_run_id, task_run_id, timestamp, level, stream, message, metadata, created_at
FROM logs
ORDER BY timestamp DESC
LIMIT $1 OFFSET $2
`

type ListLogsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListLogs(ctx context.Context, arg ListLogsParams) ([]Log, error) {
	rows, err := q.db.Query(ctx, listLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Log{}
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.JobRunID,
			&i.TaskRunID,
			&i.Timestamp,
			&i.Level,
			&i.Stream,
			&i.Message,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLogsByJobRun = `-- name: ListLogsByJobRun :many
SELECT id, type, job_run_id, task_run_id, timestamp, level, stream, message, metadata, created_at
FROM logs
WHERE job_run_id = $1
ORDER BY timestamp ASC
`

func (q *Queries) ListLogsByJobRun(ctx context.Context, jobRunID pgtype.UUID) ([]Log, error) {
	rows, err := q.db.Query(ctx, listLogsByJobRun, jobRunID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Log{}
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.JobRunID,
			&i.TaskRunID,
			&i.Timestamp,
			&i.Level,
			&i.Stream,
			&i.Message,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLogsByJobRunAndLevel = `-- name: ListLogsByJobRunAndLevel :many
SELECT id, type, job_run_id, task_run_id, timestamp, level, stream, message, metadata, created_at
FROM logs
WHERE job_run_id = $1 AND level = $2
ORDER BY timestamp ASC
`

type ListLogsByJobRunAndLevelParams struct {
	JobRunID pgtype.UUID `json:"job_run_id"`
	Level    string      `json:"level"`
}

func (q *Queries) ListLogsByJobRunAndLevel(ctx context.Context, arg ListLogsByJobRunAndLevelParams) ([]Log, error) {
	rows, err := q.db.Query(ctx, listLogsByJobRunAndLevel, arg.JobRunID, arg.Level)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Log{}
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.JobRunID,
			&i.TaskRunID,
			&i.Timestamp,
			&i.Level,
			&i.Stream,
			&i.Message,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLogsByJobRunPaginated = `-- name: ListLogsByJobRunPaginated :many
SELECT id, type, job_run_id, task_run_id, timestamp, level, stream, message, metadata, created_at
FROM logs
WHERE job_run_id = $1
ORDER BY timestamp ASC
LIMIT $2 OFFSET $3
`

type ListLogsByJobRunPaginatedParams struct {
	JobRunID pgtype.UUID `json:"job_run_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListLogsByJobRunPaginated(ctx context.Context, arg ListLogsByJobRunPaginatedParams) ([]Log, error) {
	rows, err := q.db.Query(ctx, listLogsByJobRunPaginated, arg.JobRunID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Log{}
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.JobRunID,
			&i.TaskRunID,
			&i.Timestamp,
			&i.Level,
			&i.Stream,
			&i.Message,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLogsByLevel = `-- name: ListLogsByLevel :many
SELECT id, type, job_run_id, task_run_id, timestamp, level, stream, message, metadata, created_at
FROM logs
WHERE level = $1
ORDER BY timestamp DESC
LIMIT $2 OFFSET $3
`

type ListLogsByLevelParams struct {
	Level  string `json:"level"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListLogsByLevel(ctx context.Context, arg ListLogsByLevelParams) ([]Log, error) {
	rows, err := q.db.Query(ctx, listLogsByLevel, arg.Level, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Log{}
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.JobRunID,
			&i.TaskRunID,
			&i.Timestamp,
			&i.Level,
			&i.Stream,
			&i.Message,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLogsByTaskRun = `-- name: ListLogsByTaskRun :many
SELECT id, type, job_run_id, task_run_id, timestamp, level, stream, message, metadata, created_at
FROM logs
WHERE task_run_id = $1
ORDER BY timestamp ASC
`

func (q *Queries) ListLogsByTaskRun(ctx context.Context, taskRunID pgtype.UUID) ([]Log, error) {
	rows, err := q.db.Query(ctx, listLogsByTaskRun, taskRunID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Log{}
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.JobRunID,
			&i.TaskRunID,
			&i.Timestamp,
			&i.Level,
			&i.Stream,
			&i.Message,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLogsByType = `-- name: ListLogsByType :many
SELECT id, type, job_run_id, task_run_id, timestamp, level, stream, message, metadata, created_at
FROM logs
WHERE type = $1
ORDER BY timestamp DESC
LIMIT $2 OFFSET $3
`

type ListLogsByTypeParams struct {
	Type   string `json:"type"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListLogsByType(ctx context.Context, arg ListLogsByTypeParams) ([]Log, error) {
	rows, err := q.db.Query(ctx, listLogsByType, arg.Type, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Log{}
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.JobRunID,
			&i.TaskRunID,
			&i.Timestamp,
			&i.Level,
			&i.Stream,
			&i.Message,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSystemLogs = `-- name: ListSystemLogs :many
SELECT id, type, job_run_id, task_run_id, timestamp, level, stream, message, metadata, created_at
FROM logs
WHERE type = 'system'
ORDER BY timestamp DESC
LIMIT $1 OFFSET $2
`

type ListSystemLogsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListSystemLogs(ctx context.Context, arg ListSystemLogsParams) ([]Log, error) {
	rows, err := q.db.Query(ctx, listSystemLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Log{}
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.JobRunID,
			&i.TaskRunID,
			&i.Timestamp,
			&i.Level,
			&i.Stream,
			&i.Message,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
