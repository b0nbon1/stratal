// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: job_run_pause.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getJobRunWithPauseInfo = `-- name: GetJobRunWithPauseInfo :one
SELECT jr.id, jr.job_id, jr.status, jr.started_at, jr.finished_at, jr.error_message, jr.triggered_by, jr.metadata, jr.created_at, jr.updated_at, jr.paused_at, j.name as job_name
FROM job_runs jr
JOIN jobs j ON jr.job_id = j.id  
WHERE jr.id = $1
`

type GetJobRunWithPauseInfoRow struct {
	ID           pgtype.UUID        `json:"id"`
	JobID        pgtype.UUID        `json:"job_id"`
	Status       pgtype.Text        `json:"status"`
	StartedAt    pgtype.Timestamp   `json:"started_at"`
	FinishedAt   pgtype.Timestamp   `json:"finished_at"`
	ErrorMessage pgtype.Text        `json:"error_message"`
	TriggeredBy  pgtype.Text        `json:"triggered_by"`
	Metadata     []byte             `json:"metadata"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	PausedAt     pgtype.Timestamp   `json:"paused_at"`
	JobName      string             `json:"job_name"`
}

func (q *Queries) GetJobRunWithPauseInfo(ctx context.Context, id pgtype.UUID) (GetJobRunWithPauseInfoRow, error) {
	row := q.db.QueryRow(ctx, getJobRunWithPauseInfo, id)
	var i GetJobRunWithPauseInfoRow
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Status,
		&i.StartedAt,
		&i.FinishedAt,
		&i.ErrorMessage,
		&i.TriggeredBy,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PausedAt,
		&i.JobName,
	)
	return i, err
}

const getPausedJobRuns = `-- name: GetPausedJobRuns :many
SELECT id, job_id, status, started_at, finished_at, error_message, triggered_by, metadata, created_at, updated_at, paused_at FROM job_runs 
WHERE status = 'paused'
ORDER BY paused_at DESC
`

func (q *Queries) GetPausedJobRuns(ctx context.Context) ([]JobRun, error) {
	rows, err := q.db.Query(ctx, getPausedJobRuns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []JobRun{}
	for rows.Next() {
		var i JobRun
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.Status,
			&i.StartedAt,
			&i.FinishedAt,
			&i.ErrorMessage,
			&i.TriggeredBy,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PausedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pauseJobRun = `-- name: PauseJobRun :exec
UPDATE job_runs 
SET status = 'paused', 
    paused_at = NOW(),
    updated_at = NOW()
WHERE id = $1 AND status IN ('running', 'queued')
`

func (q *Queries) PauseJobRun(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, pauseJobRun, id)
	return err
}

const pauseTaskRun = `-- name: PauseTaskRun :exec
UPDATE task_runs
SET status = 'paused',
    paused_at = NOW(), 
    updated_at = NOW()
WHERE id = $1 AND status = 'running'
`

func (q *Queries) PauseTaskRun(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, pauseTaskRun, id)
	return err
}

const resumeJobRun = `-- name: ResumeJobRun :exec
UPDATE job_runs
SET status = CASE 
    WHEN paused_at IS NOT NULL AND started_at IS NULL THEN 'queued'
    ELSE 'running'
END,
paused_at = NULL,
updated_at = NOW()
WHERE id = $1 AND status = 'paused'
`

func (q *Queries) ResumeJobRun(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, resumeJobRun, id)
	return err
}

const resumeTaskRun = `-- name: ResumeTaskRun :exec
UPDATE task_runs  
SET status = 'running',
    paused_at = NULL,
    updated_at = NOW()
WHERE id = $1 AND status = 'paused'
`

func (q *Queries) ResumeTaskRun(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, resumeTaskRun, id)
	return err
}
